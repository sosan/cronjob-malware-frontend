package tasks

import (
	"context"
	"log"
	"main/middlewares"
	"os"

	"github.com/redis/go-redis/v9"
	"go.opentelemetry.io/otel/trace"
)

const (
	PONG = "PONG"
)


func TaskReadRedis() {

  ctx, span := middlewares.GetOpenTelemetry().Start(
		context.Background(),
		"TaskReadRedis",
	)
	defer span.End()

	// recoger
  uri, ok := os.LookupEnv("URI_REDIS_CRONJOB")

  log.Printf("%s", uri)
  if !ok {
		attributes := middlewares.SetAttributesFailedEnvMalwareTrends("TaskReadRedis", "getredis.go", "no es posible obtener os.lookupenv URI_REDIS_CRONJOB")
		span.AddEvent("log", trace.WithAttributes(attributes...))

		log.Panic("ERROR | sin URI_REDIS_CRONJOB")
	}

  opt, err := redis.ParseURL(uri)
	redisClient := redis.NewClient(opt)
	defer redisClient.Close()

  if (err != nil) {
		panic(err)
	}

	status, err := redisClient.Ping(ctx).Result()
	if (err != nil) && (status != PONG) {
		panic(err)
	}

  key, ok := os.LookupEnv("KEY_REDIS_CRONJOB")

  if !ok {
		attributes := middlewares.SetAttributesFailedEnvMalwareTrends("TaskSaveTrends", "getredis.go", "no es posible obtener os.lookupenv KEY_REDIS_CRONJOB")
		span.AddEvent("log", trace.WithAttributes(attributes...))

		log.Panic("ERROR | sin KEY_REDIS_CRONJOB")
	}

	_, err = redisClient.Get(ctx, key).Result()
	if err != nil {
		attributes := middlewares.SetAttributesFailedEnvMalwareTrends("TaskSaveTrends", "getredis.go", "error conexion para obtener los datos")
		span.AddEvent("log", trace.WithAttributes(attributes...))

		log.Panic("ERROR | error conexion para obtener los datos")
	}


}
