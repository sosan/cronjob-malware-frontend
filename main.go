package main

import (
	"context"
	"fmt"
	"log"
	"main/config"
	"main/middlewares"
	"main/routes"
	"main/tasks"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/go-co-op/gocron"
	"github.com/gofiber/fiber/v2"
	"github.com/uptrace/uptrace-go/uptrace"

	"main/database"
)

func init() {
	config.SetupEnvs()

}

func main() {

	ctxTelemetry := context.Background()

	uptrace.ConfigureOpentelemetry(
		uptrace.WithDSN(os.Getenv("UPTRACE_DSN")),

		uptrace.WithServiceName("cronjob-mwalware-trends"),
		uptrace.WithServiceVersion("v1.0.0"),
		uptrace.WithDeploymentEnvironment("production"),
	)

	defer func() {
		if err := uptrace.Shutdown(ctxTelemetry); err != nil {
			log.Printf("Error shutting down tracer provider: %v", err)
		}
	}()

	database.SetupDB()

	job := gocron.NewScheduler(time.UTC)

	job.Every(1).Day().At("05:00").Do(
		tasks.TaskSaveTrends,
	)

	job.StartAsync()

	app := fiber.New()
	middlewares.Setup(app)
	routes.SetupRoutes(app)

	go func() {
		// if err := app.ListenMutualTLS(PORT_BACKEND_STRING, "./localcerts/server/cert.pem", "./localcerts/server/key.pem", "./localcerts/ca/cert.pem"); err != nil {
		if err := app.Listen(getPort()); err != nil {
			log.Panic(err)
		}

	}()

	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)

	<-c
	fmt.Println("Gracefully shutting down...")
	_ = app.Shutdown()

}

func getPort() string {
	port := os.Getenv("PORT")
	if port == "" {
		port = ":3000"
	} else {
		port = ":" + port
	}

	return port
}
