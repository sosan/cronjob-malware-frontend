package repositoriesDB

import (
	"context"
  "main/encode"
	"fmt"
	"log"
	"main/database"
	"main/middlewares"
	"main/models"
	"time"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)

func SetStrKey(key string, value interface{}) bool {

	_, span := middlewares.GetOpenTelemetry().Start(
		context.Background(),
		"SetStrKey",
		trace.WithAttributes(attribute.String("body", fmt.Sprintf("key=%s value=%v", key, value))),
	)
	defer span.End()

  dataByes := encode.CodingData(value)

	for i := 0; i < 100; i++ {

		result := database.SetStrKey(key, dataByes)
		if !result {
			log.Printf("Durmiendo .... %d segundos", i*5)
			duration := time.Second * time.Duration(i*5)
			time.Sleep(duration)

			continue
		}
		return true

	}

	dataTrace := &models.DataTrace{
		FunctionName: "SetStrKey",
		FileName:     "redis_db.go",
		Data:         fmt.Sprintf("key=%s value=%v", key, value),
		Error:        fmt.Errorf("ERROR | CANNOT SAVED FOR MORE THAN 100 ROUNDS"),
	}

	attributes := middlewares.SetAttributesFailedDB(dataTrace)
	span.AddEvent("log", trace.WithAttributes(attributes...))

	return false

}

func GetStrKey(key string) (string, bool) {

	_, span := middlewares.GetOpenTelemetry().Start(
		context.Background(),
		"SetStrKey",
		trace.WithAttributes(attribute.String("body", fmt.Sprintf("key=%s", key))),
	)
	defer span.End()

	for i := 0; i < 100; i++ {

		data, err := database.GetStrKey(key)
		if err != nil {
			continue
		}

		return data, true

	}

	dataTrace := &models.DataTrace{
		FunctionName: "GetStrKey",
		FileName:     "redis_db.go",
		Data:         fmt.Sprintf("key=%s", key),
		Error:        fmt.Errorf("ERROR | CANNOT GET DATA FOR MORE THAN 100 ROUNDS"),
	}

	attributes := middlewares.SetAttributesFailedDB(dataTrace)
	span.AddEvent("log", trace.WithAttributes(attributes...))

	return "", false

}

func Incr(key string) (int64, bool) {

	_, span := middlewares.GetOpenTelemetry().Start(
		context.Background(),
		"Incr",
		trace.WithAttributes(attribute.String("Incr", fmt.Sprintf("key=%s", key))),
	)
	defer span.End()

	for i := 0; i < 100; i++ {
		status, err := database.Incr(key)

		if err != nil {
			continue
		}

		return status, true

	}

	dataTrace := &models.DataTrace{
		FunctionName: "Incr",
		FileName:     "redis_db.go",
		Data:         fmt.Sprintf("key=%s", key),
		Error:        fmt.Errorf("ERROR | CANNOT GET DATA FOR MORE THAN 100 ROUNDS"),
	}

	attributes := middlewares.SetAttributesFailedDB(dataTrace)
	span.AddEvent("log", trace.WithAttributes(attributes...))

	return 0, false

}
